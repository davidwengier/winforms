// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace System.Windows.Forms.SourceGenerators.Tests
{
    public class EnumValidationTests
    {
        [Fact]
        public void SequentialEnum()
        {
            string source = @"
namespace People
{
    enum Names
    {
        David,
        Igor,
        Jeremy,
        Hugh,
        Tobias,
        Olia,
        Merrie
    }

    class C
    {
        void M(Names value)
        {
            EnumValidation.EnumValidator.Validate(value);
        }
    }
}";
            string expected =
@"if (intValue >= 0 && intValue <= 6) return;";

            VerifyGeneratedMethodLines(source, "People.Names", expected);
        }

        private void VerifyGeneratedMethodLines(string source, string expectedEnumName, string expectedBody, string expectedArgumentName = "value")
        {
            SyntaxTree syntaxTree = CSharpSyntaxTree.ParseText(source);

            List<MetadataReference> references = new List<MetadataReference>();
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            foreach (Assembly assembly in assemblies)
            {
                if (!assembly.IsDynamic)
                {
                    references.Add(MetadataReference.CreateFromFile(assembly.Location));
                }
            }

            CSharpCompilation compilation = CSharpCompilation.Create("original", new SyntaxTree[] { syntaxTree }, references, new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

            ISourceGenerator generator = new EnumValidationGenerator();

            CSharpGeneratorDriver driver = CSharpGeneratorDriver.Create(generator);
            driver.RunGeneratorsAndUpdateCompilation(compilation, out Compilation outputCompilation, out ImmutableArray<Diagnostic> diagnostics);
            Assert.False(diagnostics.Any(d => d.Severity == DiagnosticSeverity.Error), "Failed: " + diagnostics.FirstOrDefault()?.GetMessage());

            string output = outputCompilation.SyntaxTrees.Last().ToString();

            List<string> lines = output.Split("\r\n").ToList();

            AssertFirstLineAndRemove(lines, "// <auto-generated />");
            AssertFirstLineAndRemove(lines, "namespace EnumValidation");
            AssertFirstLineAndRemove(lines, "{");
            AssertFirstLineAndRemove(lines, "internal static class EnumValidator");
            AssertFirstLineAndRemove(lines, "{");
            AssertFirstLineAndRemove(lines, $"public static void Validate({expectedEnumName} enumToValidate)");
            AssertFirstLineAndRemove(lines, "{");
            AssertFirstLineAndRemove(lines, "int intValue = (int)enumToValidate;");

            foreach (string line in expectedBody.Split("\r\n"))
            {
                AssertFirstLineAndRemove(lines, line.Trim());
            }

            AssertFirstLineAndRemove(lines, $"throw new System.ComponentModel.InvalidEnumArgumentException(\"{expectedArgumentName}\", intValue, typeof({expectedEnumName}));");

            AssertFirstLineAndRemove(lines, "}");
            AssertFirstLineAndRemove(lines, "");
            AssertFirstLineAndRemove(lines, "}");
            AssertFirstLineAndRemove(lines, "}");
            AssertFirstLineAndRemove(lines, "");

            Assert.Empty(lines);

            static void AssertFirstLineAndRemove(List<string> lines, string expected)
            {
                Assert.True(lines.Count > 0);

                var line = lines[0].Trim();
                lines.RemoveAt(0);
                Assert.Equal(expected, line);
            }
        }
    }
}
